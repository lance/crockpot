/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as moment from "moment";

export interface TemporalUnit {
  duration?: Duration;
  timeBased?: boolean;
  dateBased?: boolean;
  durationEstimated?: boolean;
}

export interface Duration {
  seconds?: number;
  zero?: boolean;
  units?: TemporalUnit[];
  negative?: boolean;
  nano?: number;
}

export interface ZoneOffsetTransition {
  offsetBefore?: ZoneOffset;
  offsetAfter?: ZoneOffset;
  duration?: Duration;
  gap?: boolean;
  dateTimeAfter?: Date;
  dateTimeBefore?: Date;
  overlap?: boolean;
  instant?: number;
}

export interface LocalTime {
  hour?: number;
  minute?: number;
  second?: number;
  nano?: number;
}

export interface ZoneOffsetTransitionRule {
  /**
   * Possible values include: 'JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE', 'JULY',
   * 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'
  */
  month?: string;
  /**
   * Possible values include: 'UTC', 'WALL', 'STANDARD'
  */
  timeDefinition?: string;
  standardOffset?: ZoneOffset;
  offsetBefore?: ZoneOffset;
  offsetAfter?: ZoneOffset;
  /**
   * Possible values include: 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY',
   * 'SUNDAY'
  */
  dayOfWeek?: string;
  dayOfMonthIndicator?: number;
  localTime?: LocalTime;
  midnightEndOfDay?: boolean;
}

export interface ZoneRules {
  fixedOffset?: boolean;
  transitions?: ZoneOffsetTransition[];
  transitionRules?: ZoneOffsetTransitionRule[];
}

export interface ZoneOffset {
  totalSeconds?: number;
  id?: string;
  rules?: ZoneRules;
}

export interface LRAInfo {
  timeNow?: number;
  lraId?: string;
  compensated?: boolean;
  recovering?: boolean;
  finishTime?: number;
  complete?: boolean;
  topLevel?: boolean;
  zoneOffset?: ZoneOffset;
  startTime?: number;
  clientId?: string;
  active?: boolean;
  status?: string;
}

export interface LRAStatus {
  lraId?: string;
  clientId?: string;
  httpStatus?: number;
  responseData?: string;
  startTime?: number;
  finishTime?: number;
  timeNow?: number;
  /**
   * Possible values include: 'Compensating', 'Compensated', 'FailedToCompensate', 'Completing',
   * 'Completed', 'FailedToComplete'
  */
  status?: string;
  compensated?: boolean;
  recovering?: boolean;
  compensating?: boolean;
  failedToCompensate?: boolean;
  failedToComplete?: boolean;
  completing?: boolean;
  encodedResponseData?: string;
  complete?: boolean;
  topLevel?: boolean;
  completed?: boolean;
  active?: boolean;
}
